\chapter{Design}
\label{ch:design}

\section{Packet capture}
\label{sec:packet_capture}

In order for the framework to be able to adapt to the network environment, it must be able to listen to the network traffic.
I concluded that one of two options would be best suited for my needs:
\begin{itemize}
    \item libpcap
    \item A raw socket
\end{itemize}

\subsection{raw sockets}

Raw sockets provide direct access to low level protocols, this allows a program to read packets all the way down to layer two, generally the Ethernet header. 

This approach is standalone, it does not require external libraries to operate, which means the program would not need pre-existing libraries to be installed on the system, this is particularly important in some of the applications of covert channels.

There is very little code complexity involved in setting up a raw socket:

\begin{listing}
    \vspace{0.5cm}
    \begin{minted}{julia}
# Capture entire packet (AF -> Address Family)
const AF_PACKET = Cint(17) 
# Raw listening socket
const SOCK_RAW = Cint(3)
# Capture all ethernet frames
const ETH_P_ALL = Cint(0x0300)

socket = fdio(ccall(:socket,
    Cint, # Return type
    (Cint, Cint, Cint), # Argument types
    AF_PACKET, SOCK_RAW, ETH_P_ALL # Arguments
))
packet = read(socket)
    \end{minted}
    \caption{Raw socket listener implementation}
    \label{lst:raw_sock}
\end{listing}

Julia will read the socket pipe until an EOF is found, which marks the end of a packet, this lightweight and simplistic implementation means the construction of this listener is incredibly cheap and thus it is very versatile.

\subsection{libpcap}

libpcap is a cross-platform library for low-level network monitoring \cite{libpcap}. 
There are a number of benefits to using libpcap, the first being the ease of implementation, libpcap provides a simple API for capturing packets, allowing for a callback function to be called when a packet is captured, this function is passed the capture header, packet pointer, and user data if required.

Because of julia's ability to integrate seamlessly with C and its libraries, the callback function could be written in julia, removing the need to write any C code. The benefit of using a library is that it is appropriately optimised. libpcap creates a memory-mapped ring buffer for asynchronous packet reception [PACKET\_RX\_RING - https://man7.org/linux/man-pages/man7/packet.7.html], this allows the userspace to the packet data without the need for need for system calls, and the shared buffer also reduces the number of copies required.

While the platform-independent nature of libpcap is beneficial, the scope of this project is limited to linux, and thus this will not be included in my evaluation.

\subsection{Conclusion}

Both raw sockets and libpcap are viable options for packet capture, however, libpcap has a few advantages, the factor that swayed my decision was the support for the Berkeley Packet Filter (BPF). BPF's are register-based "filter machines" [The BSD Packet Filter] that makes filtering packets incredibly efficient, this is particularly useful for this project as it allows for the filtering of packets to be done in the kernel, which reduces the number of packets that need to be processed by the program. Specifically, this means the receiver can filter traffic so it only has to process packets that are destined for it, reducing the overhead.

\subsection{Note}

Eventually I decided that both implementations could be used in the framework, the raw socket was used to capture packets for the sender, without disrupting the main queue of packets. The additional code complexity of searching the queue did not outweigh the overhead of opening a raw socket, there are also some other benefits to using the raw socket, but I will discuss them in context in \ref{sec:integrity}.

\section{Packet processing}

\section{The Queue}

The queue is essential to the operation of the framework, it is how the packets are put by the listening thread, and retrieved by the main thread for processing.

Initially, I was using a \inline{Channel} data structure, it is a thread-safe, waitable, First-in-First-out queue [JULIADOCS] that worked for the most part, however it introduced a bug into my codebase that meant the listening thread would block the main thread while it was waiting for packets, thus the covert channel would not run in a silent environment.

While this isn't a huge problem, since a covert channel is quite exposed on a silent network, it is not ideal. I eventually decuded that I was improperly accessing the properties of the structure, I was attempting to get the whole queue without removing the items, so I just took it from the underlying array. Unfortunately, the \inline{Channel} is locked by default, and thus the main thread was being blocked until the listening thread pushed something to the queue.

While I knew this action was not truely thread-safe, meaning I would likely be operating with stale data, it wasn't of great importance that my queue was truely up-to-date, as I was taking a rolling average of 150 packets anyway. I didn't realise that it would cause the main thread to be intermitently blocked, additionally, this unusual behaviour meant that it was difficult to debug, especially since my print statements were reliant on packets being received by the listening thread, which caused a lot of debugging cycles to be performed.

My solution to this was to implement a new, more idomatic datastructure, the \inline{CircularChannel}. This is a thread-safe, waitable, First-in-First-out queue that behaves like a circular buffer, so that it overwrites the oldest item when it is full.

\begin{figure}[!h]
    \begin{minipage}{0.5\textwidth}
        \centering
        \begin{minted}{julia}

packet = get_packet()
if isfull(queue)
    take!(queue)
end
put!(queue, packet)

        \end{minted}
        \captionof{listing}{Old "Channel" implementation}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
        \centering
        \begin{minted}{julia}

packet = get_packet()
put!(queue, packet)

        \end{minted}
    \captionof{listing}{New "CircularChannel" implementation}
    \end{minipage}
\label{lst:queue_impl_comparison}
\end{figure}

By overloading the \inline{put!} and \inline{take!} functions, I was able to implement their functionality for my new data structure, this meant for most of the code all I had to do was replace the type annotations of \inline{Channel} with \inline{CircularChannel}. This is ofcourse with the exception of the queue, whose changes can be see in \ref{lst:queue_new} and \ref{lst:queue_old}, and the \inline{get\_queue\_data} function that I was using to improperly access the queue, thanks to my use of a central function for accessing this queue data I was able to change the implementation of the function without having to change the code that called it. I did this by creating a type convert funtion for the \inline{CircularChannel\{T\}} to \inline{Vector\{T\}}, where T is any data type, since I implemented this in a thread-safe way, I was able to use altered \inline{get\_queue\_data} function to access the queue data without blocking the main thread.

I efficiently achieved this waiting using \inline{Conditions}, they are locks that implement \inline{wait} and \inline{notify} methods that block (reducing resource usage) and release threads, respectively, based on the status of the condition. This allows my main thread to wait for the listening thread to push a packet to the queue, and then continue processing the packet (for the receiver only).

\subsection{Queriability}

One of my goals for the project was to allow any type of covert channel to be used in the framework, regardless of classification. Ultimately, this meant I was going to have to take a dynamic approach to the initialising and using channels. I concluded that it was best to be able to query the channel for certain properties in packets, like the destination port or the packet size.

I implemented a rudimentary query system, that allowed for querying of properties captured by the framework (known header values), these properties could be combined with simple logical operators (AND, OR) to sufficiently complex queries. An extract of Faucet's documentation gives an example of what these queries look like:

[ADD DOC EXAMPLE]

\section{Microprotocols}

The adaptive covert channel is reliant on the underlying protocols, these protocols are used to implement:
\begin{itemize}
    \item Describing the nature of a payload
    \item Starting communication
    \item Ending communication
    \item Switching active channel (The one being used for communication)
    \item Verifying integrity of the communication
    \item Discarding chunks of data that have been corrupted
    \item Recovering from a disconnection in communication
\end{itemize}

Inorder to implement these protocls effectively, using the contextless design proposed in \ref{sec:DRiCCBoCP}, packets need to desribe their nature, I decided to implement this using a single bit, at the start of the payload. '0' and '1' indicate whether the packet is data or metadata, respectively. Protocols are implemented as metadata, and are of adaptive length, the size of these protocols is a function of the number of underlying channels that may be used. The minimum channel size is $1 + \floor{log_2{M_c + 1}}$ where M\textsubscript{c} is the number of underlying covert methods.
